"""
Copyright (c) 2015, 2020 The Linux Foundation. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of The Linux Foundation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

IPC Logging Extraction Tool
---------------------------

Can be used on RAM dumps (files containing binary data that are produced after
a crash) to extract logs generated by IPC Logging. The dumps must be given in
the order they were written, so that all data can be found.
"""

import os
import struct

from print_out import print_out_str
from parser_util import register_parser, RamParser
import linux_list as llist

TSV_TYPE_INVALID = 0
TSV_TYPE_TIMESTAMP = 1
TSV_TYPE_POINTER = 2
TSV_TYPE_INT32 = 3
TSV_TYPE_BYTE_ARRAY = 4
TSV_TYPE_QTIMER = 5
IPC_LOG_CONTEXT_MAGIC_NUM = 0x25874452
IPC_LOGGING_MAGIC_NUM = 0x52784425


@register_parser('--ipc_logging', 'print ipc_logging information')
class ipc_logging_cn(RamParser):

    def __init__(self, *args):
        super(ipc_logging_cn, self).__init__(*args)

    def next_page(self, ipc_log_context, curr_read_page):
        hdr_addr = self.ramdump.struct_field_addr(
            curr_read_page, 'struct ipc_log_page', 'hdr')
        list_addr = self.ramdump.struct_field_addr(
            hdr_addr, 'struct ipc_log_page_header', 'list')

        next = self.ramdump.read_word(list_addr)
        pagelist_addr = self.ramdump.struct_field_addr(
            ipc_log_context, 'struct ipc_log_context', 'page_list')

        if next == pagelist_addr:
            next = self.ramdump.read_word(next)

        hdr = self.ramdump.container_of(
            next, 'struct ipc_log_page_header', 'list')
        ipc_log_page = self.ramdump.container_of(
            hdr, 'struct ipc_log_page', 'hdr')
        return ipc_log_page

    def decode_buffer(self, final_buf, output):
        tsv_header_struct_size = self.ramdump.sizeof('struct tsv_header')
        pos = 0
        while pos < len(final_buf):
            tsv_msg_type, tsv_msg_size = struct.unpack_from("BB", final_buf, pos)
            pos += tsv_header_struct_size

            this_msg = pos
            # TSV_TYPE_TIMESTAMP
            this_msg_type, this_msg_size = struct.unpack_from("BB", final_buf, this_msg)

            if this_msg_type == TSV_TYPE_TIMESTAMP:
                this_msg = this_msg + tsv_header_struct_size
                fmt = 'L'
                if this_msg_size == 8:
                    fmt = 'Q'
                TimeStamp, = struct.unpack_from(fmt, final_buf, this_msg)
                this_msg = this_msg + this_msg_size

            # TSV_TYPE_QTIMER
            TimeQtimer = 0
            this_msg_type, this_msg_size = struct.unpack_from("BB", final_buf, this_msg)

            if this_msg_type == TSV_TYPE_QTIMER:
                this_msg = this_msg + tsv_header_struct_size
                fmt = 'L'
                if this_msg_size == 8:
                    fmt = 'Q'
                TimeQtimer, = struct.unpack_from(fmt, final_buf, this_msg)
                this_msg = this_msg + this_msg_size

            # TSV_TYPE_BYTE_ARRAY
            this_msg_type, this_msg_size = struct.unpack_from("BB", final_buf, this_msg)

            if this_msg_type == TSV_TYPE_BYTE_ARRAY:
                this_msg = this_msg + tsv_header_struct_size
                output_str = final_buf[this_msg:this_msg + this_msg_size].decode('utf-8', 'ignore')
                if '\n' in output_str:
                    output.write(
                        "[ {0:10.9f}       0x{1:x}]   {2}".format(
                            TimeStamp / 1000000000.0, TimeQtimer, output_str))
                else:
                    output.write(
                        "[ {0:10.9f}       0x{1:x}]   {2}\n".format(
                            TimeStamp / 1000000000.0, TimeQtimer, output_str))
            pos += tsv_msg_size

    def do_ipc_log_context_parser(self, ipc_log_context):

        name_addr = self.ramdump.struct_field_addr(
            ipc_log_context, 'struct ipc_log_context', 'name')
        name = self.ramdump.read_cstring(name_addr)
        nd_read_page = self.ramdump.read_structure_field(
            ipc_log_context, 'struct ipc_log_context', 'nd_read_page')

        start_read_page = nd_read_page
        curr_read_page = start_read_page
        hdr_addr = self.ramdump.struct_field_addr(
            start_read_page, 'struct ipc_log_page', 'hdr')
        magic = self.ramdump.read_structure_field(
            hdr_addr, 'struct ipc_log_page_header', 'magic')

        if magic != IPC_LOGGING_MAGIC_NUM:
            print_out_str("wrong magic in ipc_log_page_header 0x{0:x} "
                          .format(hdr_addr))
            return

        file_name = "{0}.txt".format(name)
        f_path = os.path.join(self.output_dir, file_name)
        output = open(f_path, "w")
        output.write("=====================================================\n")
        output.write("IPC log for {0} \nv.v (struct ipc_log_context *)0x{1:x}\n"
                     .format(name, ipc_log_context))
        output.write("=====================================================\n")

        LOG_PAGE_DATA_OFFSET = self.ramdump.field_offset(
            'struct ipc_log_page', 'data')
        STRUCT_IPC_LOG_PAGE_SIZE = self.ramdump.sizeof('struct ipc_log_page')
        LOG_PAGE_DATA_SIZE = STRUCT_IPC_LOG_PAGE_SIZE - LOG_PAGE_DATA_OFFSET

        nd_read_offset = self.ramdump.read_structure_field(
            hdr_addr, 'struct ipc_log_page_header', 'nd_read_offset')
        write_offset = self.ramdump.read_structure_field(
            hdr_addr, 'struct ipc_log_page_header', 'write_offset')

        if nd_read_offset <= write_offset:
            wrapped_around = 0
        else:
            wrapped_around = 1

        final_buf = bytes()
        stop_copy = 0
        while stop_copy != 1:
            hdr_addr = self.ramdump.struct_field_addr(
                curr_read_page, 'struct ipc_log_page', 'hdr')
            nd_read_offset = self.ramdump.read_structure_field(
                hdr_addr, 'struct ipc_log_page_header', 'nd_read_offset')
            write_offset = self.ramdump.read_structure_field(
                hdr_addr, 'struct ipc_log_page_header', 'write_offset')
            start_addr = curr_read_page + LOG_PAGE_DATA_OFFSET + nd_read_offset

            if nd_read_offset <= write_offset:
                bytes_to_copy = write_offset - nd_read_offset
            else:
                bytes_to_copy = LOG_PAGE_DATA_SIZE - nd_read_offset

            if bytes_to_copy < 0:
                stop_copy = 1
                break
            next_page = self.next_page(ipc_log_context, curr_read_page)

            if next_page == start_read_page:
                stop_copy = 1
            buf = self.ramdump.read_physical(
                self.ramdump.virt_to_phys(start_addr), bytes_to_copy)
            final_buf += buf
            if (wrapped_around == 0) and (write_offset < LOG_PAGE_DATA_SIZE):
                break
            curr_read_page = next_page

        if wrapped_around == 1:
            hdr_addr = self.ramdump.struct_field_addr(
                start_read_page, 'struct ipc_log_page', 'hdr')
            write_offset = self.ramdump.read_structure_field(
                hdr_addr, 'struct ipc_log_page_header', 'write_offset')
            bytes_to_copy = write_offset
            start_addr = start_read_page + LOG_PAGE_DATA_OFFSET

            buf = self.ramdump.read_physical(
                self.ramdump.virt_to_phys(start_addr), bytes_to_copy)
            final_buf += buf

        self.decode_buffer(final_buf, output)
        output.close()

    def ipc_log_context_list_func(self, ipc_log_context):
        magic = self.ramdump.read_structure_field(
            ipc_log_context, 'struct ipc_log_context', 'magic')
        if magic != IPC_LOG_CONTEXT_MAGIC_NUM:
            print_out_str("wrong magic in ipc_log_context  0x{0:x} "
                          .format(ipc_log_context))
            return

        self.do_ipc_log_context_parser(ipc_log_context)

    def get_ipc_log_context_list(self, ram_dump):
        ipc_log_context_list = ram_dump.address_of('ipc_log_context_list')
        list_offset = self.ramdump.field_offset(
            'struct ipc_log_context', 'list')
        list_walker = llist.ListWalker(
            self.ramdump, ipc_log_context_list, list_offset)
        list_walker.walk(ipc_log_context_list, self.ipc_log_context_list_func)

    def parse(self):
        self.output_dir = os.path.join(os.path.abspath(
            self.ramdump.outdir), "ipc_logging")
        if os.path.exists(self.output_dir) is False:
            os.makedirs(self.output_dir)
        self.get_ipc_log_context_list(self.ramdump)
